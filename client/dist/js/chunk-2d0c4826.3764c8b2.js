(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0c4826"],{"3aac":function(e,t,n){"use strict";n.r(t);var s=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("article",{staticClass:"snippet-article"},[n("h1",{staticClass:"hero-title"},[e._v("Stream updates natively with with EventSource")]),e._m(0),e._m(1),e._m(2),n("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[n("code",{staticClass:"javascript"},[e._v("\n    const evtSource = new EventSource('/connect');\n\n    // Listen for \"open\" event when connected\n    evtSource.addEventListener('open', () => {\n      console.log('Persistent connection to server opened');\n    });\n\n    // Listen for \"message\" event when received from server\n    evtSource.addEventListener('message', e => {\n      console.log('Data received: ', e.data);\n    });\n  ")])]),n("p",[e._v(" Here's a NodeJS server example that listens for the initial request and simulates sending periodic events: ")]),n("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[n("code",{staticClass:"javascript"},[e._v("\n    app.get('/connect', (req, res) => {\n\n      // Set headers\n      res.status(200).set({\n        'Connection': 'keep-alive',\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache'\n      });\n\n      // Broadcast a message with a random # every 2 seconds\n      setInterval(() => {\n        const number = Math.floor((Math.random() * 100));\n        res.write(`data: ${number} \\n\\n`);\n      }, 2000);\n  ")])]),e._m(3),e._m(4),e._m(5),e._m(6),e._m(7),n("p"),n("h3",[e._v("Links")]),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/EventSource"}},[e._v("MDN Article on EventSource")])])},a=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" The "),n("code",[e._v("EventSource")]),e._v(" object is a native Web interface used with server-sent events. If you're not familiar, server-sent events are messages sent by a server to client at any time (and not necessarily as an immediate response to a request like the tradition client-server model). ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" The most typical use case for using "),n("code",[e._v("EventSource")]),e._v(" is wherever you need to broadcast periodic events from your server, such as an online stock quote application or perhaps a social medial site where users can see real-time notifications. Using "),n("code",[e._v("EventSource")]),e._v(", you can open a persistent connection to your server and push events to your client without the need to constantly poll for updates. ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" To see how this works, first create a new "),n("code",[e._v("EventSource")]),e._v(" in your client code. The first argument is the URL of the server serving the events. From there, you can add event listeners for the "),n("code",[e._v("open")]),e._v(" and "),n("code",[e._v("message")]),e._v(" events: ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" Some caveats: First, the headers should be exactly as shown since the events are sent in "),n("code",[e._v("text/event-stream")]),e._v(" format and the connection needs to be kept alive with no caching. ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" Secondly, when testing this, I had trouble receiving events on the client until I read that the event stream response format is very particular. The response text must begin with "),n("code",[e._v("data: ")]),e._v(". The custom message should follow and the line must be terminated with 2 "),n("code",[e._v("\\n")]),e._v(" characters otherwise the message will not be sent. You can send bigger bits of data by simply using "),n("code",[e._v("JSON.stringify()")]),e._v(" on an object. ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" When you wish to close the connection simply run "),n("code",[e._v("evtSource.close()")]),e._v(". ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" There's a bunch more on "),n("code",[e._v("EventSource")]),e._v(" you can read on the MDN article linked below but that's how it works in a nutshell. What's really cool is that it's available natively in all modern browsers and is a much lighterweight alternative to using a websocket library when all you need to do is broadcast events (websocket are needed for full-duplex communications however). ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" Lastly, althougth "),n("code",[e._v("EventSource")]),e._v(" has been around forever, I first read about it as a sneaky way hackers can open connections to a malicious server in a XSS attack. Even if Security Ops are monitoring requests by watching "),n("code",[e._v("fetch")]),e._v(" events or "),n("code",[e._v("XMLHttpRequest")]),e._v(", "),n("code",[e._v("EventSource")]),e._v(" may not always be noticed (perhaps because it's more obscure?). In any case, it's a pretty cool tool to use when the situation calls for it! ðŸ“¡ ")])}],o=n("2877"),r={},i=Object(o["a"])(r,s,a,!1,null,null,null);t["default"]=i.exports}}]);
//# sourceMappingURL=chunk-2d0c4826.3764c8b2.js.map