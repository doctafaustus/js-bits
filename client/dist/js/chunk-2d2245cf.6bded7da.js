(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d2245cf"],{e08f:function(e,t,s){"use strict";s.r(t);var n=function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("article",{staticClass:"snippet-article"},[s("h1",{staticClass:"hero-title"},[e._v("Symbols Are Your Friend Series Part VI: Symbol.match, Symbol.matchAll & Symbol.replace")]),s("p",[e._v(" Well, we've made it this far ðŸ˜…. We might as well explore the remaining Symbol properties. There's only 6 more left, but we'll break them up into 2 more articles. Today we'll look at: ")]),e._m(0),s("hr"),e._m(1),s("p",[e._v(" This symbol defines the matching behavior of a regular expression against a string. Here are 2 interesting ways this can be used: ")]),e._m(2),s("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s("code",{staticClass:"javascript"},[e._v("\n    const myRegex = /abc/;\n    '/abc/'.startsWith(myRegex); // Throws error\n\n    // Override myRegex to not be treated as a regular expression\n    myRegex[Symbol.match] = false;\n    '/abc/'.startsWith(myRegex); // true\n  ")])]),e._m(3),s("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s("code",{staticClass:"javascript"},[e._v("\n    const myRegex = /abc/;\n    myRegex[Symbol.match] = function(string) {\n      const index = string.search(this);\n      if (index > -1) return `Match found @ index ${index}`;\n      return 'No match found';\n    };\n\n    'I know my 123\\'s'.match(myRegex); // Returns \"No match found\"\n  ")])]),s("hr"),e._m(4),e._m(5),s("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s("code",{staticClass:"javascript"},[e._v("\n    const myRegex = /wood/g;\n    const str = 'How much wood would a woodchuck chuck?';\n\n    for (result of str.matchAll(myRegex)) {\n      console.log(result);  // Logs matches\n    }\n  ")])]),e._m(6),s("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s("code",{staticClass:"javascript"},[e._v("\n    const myRegex = /wood/g;\n    const str = 'How much wood would a woodchuck chuck?';\n\n    for (result of myRegex[Symbol.matchAll](str)) {\n      console.log(result); // Logs matches\n    }\n  ")])]),e._m(7),s("hr"),e._m(8),e._m(9),s("p",[e._v("Default behavior:")]),s("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s("code",{staticClass:"javascript"},[e._v("\n    const spoonRegex = /spoon/;\n\n    const result = 'There is no spoon'.replace(spoonRegex, 'fork');\n    console.log(result); // Logs \"There is no fork\"\n  ")])]),s("code",[e._v("Symbol.replace")]),e._v(" modification: "),s("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s("code",{staticClass:"javascript"},[e._v("\n    const spoonRegex = /spoon/;\n    spoonRegex[Symbol.replace] = function(string, replacement) {\n      const match = string.match(this) || [];\n      const index = match.index;\n\n      if (!match.length) return string;\n      return `${string.slice(0, index)}${replacement}, lol`;\n    };\n\n    const result = 'There is no spoon'.replace(spoonRegex, 'fork');\n    console.log(result); // Logs \"There is no fork, lol\"\n  ")])])])},r=[function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ul",[s("li",[s("code",[e._v("Symbol.match")])]),s("li",[s("code",[e._v("Symbol.matchAll")])]),s("li",[s("code",[e._v("Symbol.replace")])])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[s("b",[s("code",[e._v("Symbol.match")])])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v(" The first way allows us to override the internal check within certain String methods (like "),s("code",[e._v(".startsWith()")]),e._v(", "),s("code",[e._v(".includes()")]),e._v(", etc.) that check if the first argument is erroneously an regular expression. This internal check uses the "),s("code",[e._v("match")]),e._v(" property so if we simple set it to false we can make our regex act as if it's not a regex and use those String methods: ")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v(" The other way we can use "),s("code",[e._v("Symbol.match")]),e._v(" is similar to some of the other well-known symbols we've seen already like "),s("code",[e._v("Symbol.split")]),e._v(": ")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[s("b",[s("code",[e._v("Symbol.matchAll")])])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v(" This symbol is a method that returns an iterator of results when you match a regular expression against a string. Before we check this out, note that there's already a "),s("code",[e._v("String.prototype.matchAll()")]),e._v(" method that does the inverse: it matches a string against a regular expression: ")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v(" So with "),s("code",[e._v("Symbol.matchAll")]),e._v(" we can essentially swap the calling object and argument types: ")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[s("code",[e._v("RegExp.matchAll()")]),e._v(" would otherwise throw a TypeError.")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[s("b",[s("code",[e._v("Symbol.replace")])])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("p",[e._v("This symbol defines the behavior for the "),s("code",[e._v(".replace()")]),e._v(" method on a string.")])}],o=s("2877"),a={},i=Object(o["a"])(a,n,r,!1,null,null,null);t["default"]=i.exports}}]);
//# sourceMappingURL=chunk-2d2245cf.6bded7da.js.map